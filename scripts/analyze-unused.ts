
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT_DIR = path.resolve(__dirname, '..');
const EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx', '.css', '.scss', '.json'];
const IGNORE_DIRS = ['node_modules', '.git', 'dist', 'build', '.gemini', 'scripts'];
const IGNORE_FILES = [
    'vite.config.ts', 'vite.config.js',
    'tailwind.config.js', 'tailwind.config.ts',
    'postcss.config.js',
    'playwright.config.ts',
    'package.json', 'package-lock.json',
    'tsconfig.json', 'tsconfig.node.json',
    'stats.html', // generated by build
    'supabase_schema.sql',
    'README.md', 'LICENSE'
];

// Helper to check if file exists with extensions
function resolveFile(filePath: string): string | null {
    if (fs.existsSync(filePath) && fs.statSync(filePath).isFile()) return filePath;
    for (const ext of EXTENSIONS) {
        if (fs.existsSync(filePath + ext)) return filePath + ext;
        if (fs.existsSync(path.join(filePath, 'index' + ext))) return path.join(filePath, 'index' + ext);
    }
    return null;
}

// Helper to parse imports
function getImports(content: string): string[] {
    const imports: string[] = [];
    
    // Import from
    const importRegex = /import\s+.*?\s+from\s+['"](.*?)['"]/g;
    let match;
    while ((match = importRegex.exec(content)) !== null) {
        imports.push(match[1]);
    }

    // Export from
    const exportRegex = /export\s+.*?\s+from\s+['"](.*?)['"]/g;
    while ((match = exportRegex.exec(content)) !== null) {
        imports.push(match[1]);
    }

    // Dynamic import
    const dynamicImportRegex = /import\(['"](.*?)['"]\)/g;
    while ((match = dynamicImportRegex.exec(content)) !== null) {
        imports.push(match[1]);
    }

    // CSS imports in CSS/SCSS (simplified)
    const cssImportRegex = /@import\s+['"](.*?)['"]/g;
    while ((match = cssImportRegex.exec(content)) !== null) {
        imports.push(match[1]);
    }

    return imports;
}

const visited = new Set<string>();

function traverse(filePath: string) {
    const absolutePath = resolveFile(filePath);
    if (!absolutePath || visited.has(absolutePath)) return;
    
    visited.add(absolutePath);
    
    const content = fs.readFileSync(absolutePath, 'utf-8');
    const importPaths = getImports(content);
    
    for (const imp of importPaths) {
        if (imp.startsWith('.')) {
            // Relative path
            const resolved = path.resolve(path.dirname(absolutePath), imp);
            traverse(resolved);
        } else if (imp.startsWith('@/')) {
            // Alias path
            const resolved = path.resolve(ROOT_DIR, imp.substring(2));
            traverse(resolved);
        }
        // Ignore node_modules imports (non-relative, non-alias)
    }
}

// Get all project files
function getAllFiles(dir: string): string[] {
    let results: string[] = [];
    const list = fs.readdirSync(dir);
    
    for (const file of list) {
        const fullPath = path.join(dir, file);
        const stat = fs.statSync(fullPath);
        
        if (IGNORE_DIRS.includes(file)) continue;
        if (file.startsWith('.')) continue; // ignore hidden files
        
        if (stat && stat.isDirectory()) {
            results = results.concat(getAllFiles(fullPath));
        } else {
            // Check extension
            if (EXTENSIONS.includes(path.extname(file)) || file.endsWith('.d.ts')) {
                results.push(fullPath);
            }
        }
    }
    return results;
}

function main() {
    console.log('Starting analysis from index.tsx...');
    const entryPoint = path.join(ROOT_DIR, 'index.tsx'); // Based on previous observation
    
    if (resolveFile(entryPoint)) {
        traverse(entryPoint);
    } else {
        console.error('Entry point index.tsx not found!');
        process.exit(1);
    }

    // Also check index.html for referenced scripts
    const indexHtml = path.join(ROOT_DIR, 'index.html');
    if (fs.existsSync(indexHtml)) {
        visited.add(indexHtml);
        // We know it imports index.tsx (handled above) 
        // but let's check for other scripts if any
    }

    console.log('Scanning all files...');
    const allFiles = getAllFiles(ROOT_DIR);
    
    const unusedFiles = allFiles.filter(f => {
        // Normalize for comparison
        return !visited.has(f) && !IGNORE_FILES.includes(path.basename(f));
    });

    console.log('\n--- Unused Files Analysis ---');
    if (unusedFiles.length === 0) {
        console.log('No unused files found!');
    } else {
        console.log(`Found ${unusedFiles.length} potentially unused files:`);
        unusedFiles.forEach(f => {
             console.log(path.relative(ROOT_DIR, f));
        });
    }
}

main();
